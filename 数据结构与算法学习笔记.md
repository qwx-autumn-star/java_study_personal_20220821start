# #数据结构

@

##### 总览：

​	<u>线性表：</u>顺序表，链表，栈，队列//一对一关系。

​	<u>树存储结构：</u>普通树，二叉树，线索二叉树等//一对多关系。

​	<u>图存储结构：</u>//多对多关系。

------

##### 数据的逻辑结构与存储结构（物理结构）：

​	<u>数据结构存储成功的条件是能够完整复原。</u>

​	<u>逻辑结构：</u>简单来说就是指元素之间的关系。体现在数据结构上就是线性表的一对关系，树存储结构的一对多关系和图存储结构的多对多关系。其中，通过元素之间的逻辑关系决定的是使用哪种存储结构，但具体是使用顺存储还是链式存储要通过元素的物理结构决定。

​	存储结构（物理结构）：元素本身的存储结构即物理结构，指的是数据元素在物理存储空间上选择集中存放还是分散存放，选择哪个主要取决于设备的状态以及数据的用途等具体因素。

------

##### 时间复杂度和空间复杂的：

​	<u>算法能够完全解决问题体现的是准确性，在任何条件下不崩溃体现的是健壮性，以及算法的效率，结合起来就是衡量算法的标准。</u>

​	<u>时间复杂度：</u>是一个经过合理方法给出的”准确”的预估值，先计算每条语句的时间，再计算总时间就是时间复杂度。每条语句执行的次数称为语句的频度。一般使用无限大思想进行简化：首先简化式子中的常数项，之后只保留拥有最高指数的项，最后最高项如果有不为1的系数则系数也可以去掉。

​		*格式：*O(简化后的频度和)。

​		*常见*：O(1)常数阶<O(logn)对数阶<O(n)线性阶<O(n^2)平方阶<O(n^3)立方阶<O(2^n)指数阶。

​	<u>空间复杂度：</u>一般来说，对算法的空间复杂度影响最大的是程序运行时临时申请的存储空间。如果程序占用的存储空间和输入值无关，则该程序的空间复杂度就为 O(1)，如果有关，根据相关关系结果如下：随着输入值 n 的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n) 表示。成n^2关系增长，则用 O(n2) 表示。成n^3关系增长，则用 O(n3) 表示。以此类推。

------

##### 线性表：

​	<u>将具有一对一关系的数据线性地存储到物理地址中，这种结构被称为线性表（线性存储结构），要求数据类型一致。</u>

​	<u>线性表分为：</u>

​		*顺序存储结构：*在线性的前提下元素存储在连续的物理地址中。

​		*链式存储结构：*在线性的前提下元素分散存储在物理地址中。

​	<u>前驱和后继：</u>

​		数据元素（简称数据，元素）所有前边的元素称为前驱元素，最靠近的前一个元素称为直接前驱。元素所有后边的元素称为后继元素，最靠近的后一个元素称为直接后继。



###### 顺序表（顺序存储结构）：

​		<u>顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。</u>

<u>初始化：</u>

```java
Class Table{
    final int TABLE_SIZE=10;//要提前申请的空间大小
	int[] array;//表空间
	int usedSize;//记录已使用空间大小
	public int[] initTable(){
        try{
            array=new int[TABLE_SIZE];
			return array;//成功操作
        }catch(Exception e){
            return 0;//失败操作
         }
    }
}
```

<u>基本操作：</u>

<u>插入元素：</u>分为插入到表头，插入到表尾和中间插入三种情况，前两种直接插入就好，中间位置插入则需要首先判断空间是否允许插入操作，之后通过遍历找到要插入的位置，再之后将插入位置的元素及后续所有元素整体后落一个位置，最后将元素插入到空出的目标位置上。

```java
public boolean isFull(){
    return this.array.length==this.usedSize;
}
public void add(int pos,int date){
    if(pos<0||pos>this.usedSize){//判断位置是否合法
        System.out.println("插入位置不合法");
        return;
    }
    if(ifFull()){//判断表是否已满
    	this.array=Arrays.copyOf(this.array,this.usedSize+1);//扩容操作
    }
    for(int i=this.usedSize-1;i>pos;i--){//由后向前，依次落动
        this.array[i+1]=this.array[i];       
    }
    this.array[pos]=date;//执行插入价格
    this.usedSize++;
}
```

<u>打印输出：</u>

```java
public void display(){
    for(int i=0;i<this.usedSize;i++){//从下标0开始遍历
        System.out.println(this.array[i]+"");
    }
}
```

<u>判断顺序表中是否有某个元素或查找其下标值：</u>

```java
public boolean contains(int elem){
    for(int i=0;i<this.usedSize;i++){
        if(elem==this.array[i]){
            return true;//return i;返回i是查找下标的方法
        }
    }
    return false;//return -1;对应返回下标i的方法
}
```

<u>更新顺序表对应位置的元素或查找对应位置的元素值：</u>需要判断下标是否越界和顺序表是否为空。

```java
public void sgPos(int pos,int value){
    if(pos<0||pos>this.usedSize){
        System.out.println("pos下标越界");
        return;//return -1;
    }
    if(ifEmp()){//ifEmp()是判断顺序表是否为空的方法
        System.out.println("顺序表为空");
        return;//return -1;
    }
    this.array[pos]=value;//return this.array[pos];
}
```

<u>删除顺序表中指定的元素：</u>删除元素和增加元素类似，但是需要先删除元素，随后再将删除位置后面所有元素依次向前落动一位。

```java
public void remove(int toRemove){//删除第一次出现的匹配元素
    if(ifEmp()){
        System.out.println("空顺序表");
        return;
    }
    if(-1==search(toRemove)){//search()是上述中的查找方法
        System.out.println("不存在");
        return;
    }
    for(int i=search(toRemove);i<this.usedSize-1;i++){
        this.array[i]=this.array[i+1];//由前至后移动
    }
    this.usedSize++;
}
```

<u>获取顺序表长度：</u>即获取this.usedSize的值。

<u>清空顺序表：</u>在遵循usedSize为0时判断顺序表为空表的条件下，只将usedSize置0也可以。

<u>顺序表时间复杂度及特点：</u>

​	查找O(1) 更新O(1)插入 O(n)删除O(n)。

​	顺序表的优势在于查找与更新一个元素



###### 链式存储结构（简称链表或单链表）：

​	<u>将具有一对一关系的数据通过指针保留先后关系但随机地存储在物理地址上，物理存储空间随之第一个节点的创建而开辟，随着每一个节点的变动而申请和释放。链表的每个元素由两部分组成，即存储数据的数据域和指向下一个元素的指针域。</u>

​	<u>在链表中存在</u>：

​		*头指针：*永远指向链表第一个元素，用于指明链表的位置。当存在头节点时码头指针指向头节点，但头节点不存在时，头指针指向首元节点。

​		*头节点：*链表的第一个节点并且这个节点不存储任何数据，头节点不是必须的。

​		*首元节点：*除去头节点（如果存在），链表第一个存有数据的节点，仅作称呼，没有特殊意义。

​		*其他节点：*除头节点和首元节点外的其他节点。

<u>初始化：</u>创建一个链表需要首先声明一个头指针，如果有需要，再同时创建一个头节点，之后开始创建多个存储有数据的节点（首元节点和其他节点），在创建过程中，每一个节点必须与其直接前驱或直接后继建立联系。

<u>创建节点类：</u>

```java
Class NodeList{//节点类
    public int date;//数据域
    public NodeList next;//下一个节点的引用，即指针域
    public NodeList(int num){//利用构造方法赋值
        this.date=num;
    }
}
```

<u>创建链表：</u>任何一个链表的构建必须首先有一个第一个节点，这个节点可以是头节点，也可以是首元节点。

```java
Class Table{
    public Nodelist head;//声明第一个节点
	public MyLinkedList(int num){
    	this.head=new NodeList(num);//创建链表第一个节点
    }
}
```

<u>基本操作：</u>

<u>查看链表长度：</u>遍历链表，以下一个节点为null为标志结束遍历。

```java
public int size(){
    int count=0;
    NodeList cur=this.head;
    while(cur!=null){
        count++;
        cur=cur.next;
    }
    return count;
}
```

<u>查找指定元素是否在单链表内：</u>遍历单链表，以第一个匹配指定元素要求的节点为标志结束遍历。

```java
public boolean contains(int key){
    Nodelist cur=this.head;//设置起始位置为第一个节点
    while(cur!=null){
        if(cur.date==key){//返回标志
             return true;
        }
       cur=cur.next;//预备执行下一循环
    }
    return false;
}
```

<u>在链表指定位置插入元素：</u>

<u>尾部插入：</u>直接将当前链表最后一个节点指针域指向插入节点即可。

```java
public void addLast(int num){
    NodeList nodeList=new NodeList(num);
    if(this.head==null){
        this.head=nodeList;
    }else{
        NodeList cur=this.head;
        while(cur.next!=null){
            cur=cur.next;
        }
        cur.next=nodeList;
    }
}
```

<u>头部插入：</u>首先将插入节点的指针域指向链表的第一个节点，之后更新链表的头指针指向插入节点。

```java
public void addFirst(int num){
    NodeList nodeList=new NodeList(num);
    nodeList.next=this.head;
    this.head=nodeList;
}
```

<u>中间插入：</u>首先将插入节点的指针域指向插入位置的节点，之后将插入位置节点的直接前驱的指针域指向擦汗如节点。

```java
public NodeList findIndex(int index){
    NodeList cur=this.head;
    while((index-1)!=0){//index是真实位置，与下标相较需要-1
        cur=cur.next;
        index--;
    }
    return cur;
}
public void addIndex(int index,int num){
    if(index<0||index>size()){
        System.out.println("erro");
        return;
    }
    if(index>=0&&index<=size()&&size()==0){
        addFirst(num);
        return;
    }
    if(index==size()){
        addLast(num);
        return;
    }
    NodeList nodeList=new NodeList(num);
    NodeList cur=findIndex(index);
    nodeList.next=cur.next;
    cur.next=nodeList;
}
```

<u>指定元素删除(第一次出现)：</u>

<u>尾部删除：</u>最为简单，把倒数第二个结点的指针域置空即可。
<u>头部删除：</u>把链表原先的头指针指向原链表的第二个节点即可。
<u>中间删除：</u>把要删除的结点的直接前驱的指针域指向要删除元素的直接后继。

```java
public NodeList searchPerv(int key){
    NodeList cur =this.head;
    while(cur!=null){
        if(cur.next.date==key){
            return cur;
        }
        cur=cur.next;
    }
    return null;
}
public void remove(int key){
    if(this.head==null){
        System.out.println("erro");
        return;
    }
    if(this.head.date==key){
        this.head=this.head.next;
        return;
    }
    NodeList cur=searchPerv(key);
    NodeList del=cur.next;
    cur.next=del.next;
}
```

<u>链表的打印：</u>
<u>打印整个链表：</u>只需要遍历链表，依次打印结点上的元素即可

```java
public void display(){
    NodeList cur=this.head;
    while(cur!=null){
        System.out.print(cur.date+" ");
        cur=cur.next;
    }
    System.out.println();
}
```

<u>在指定位置（确认元素）开始打印：</u>

```java
public void display(NodeList newHead){
    NodeList cur=newHead;
    while(cur!=null){
        System.out.println(cur.date+" ");
        cur=cur.next;
    }
    System.out.println();
}
```

<u>清空链表：</u>这个清空链表会出现一个比较棘手的问题，就是假如我们从头节点开始释放把每一个引用释放null，但是当我们第一次释放完结点引用时会发现整个链表后面全都丢了，所有这时候我们就需要设定一个哨兵结点，在每次释放之前我们记录头节点的位置，然后等头结点释放完毕之后，我们就不必丢失之前的位置了。

```java
public void clear(){
    while(this.head!=null){
        Nodelist curNext=head.next;
        this.head.next=null;
        this.head=curNext;
    }
}
```

<u>链表时间复杂度及特点：</u>
​	查找O(n) 更新O(1) 插入O(1) 删除O(1)
​	链表的优势在于插入和删除。



###### 单链表的反转（翻转或逆置）：

​	<u>分别有迭代反转法、递归反转法、就地逆置法和头插法，其中递归反转法更适用于反转不带头节点的链表，其他相关算法无此要求。</u>

<u>迭代反转链表：</u>从当前链表的首元节点开始，一直遍历至链表的最后一个节点，这期间会逐个改变所遍历到的节点的指针域，令其指向前一个节点。
首先判断链表是否为空表或只含一个节点，若不是则依次设置beg指向空，mid指向第一个节点，end指向mid指向节点的直接后继。之后将mid指向节点指针域指向beg指向节点，并将分别beg，mid和end向后移一个节点。重复这一过程直至end所指内容为空，则将mid所指节点指针域指向beg所指节点，同时这一次不对beg，mid和end进行后移，最后改变链表头指针指向mid所指节点即可。

```java
public NodeList iteration_reverse（NodeList head）{//迭代反转法，head 为无头节点的链表的头指针
    if(head==null||head.next==null){
        return head;
    }
    else{
        NodeList beg=null;
        NodeList mid=head;
        NodeList end=head.next;
        while(true){
            mid.next=beg;
            if(end==null){
                break;
            }
            beg=mid;
            mid=end;
            end=end.next;
        }
        head=mid;
        return head;
    }
}
```

<u>递归反转链表：</u>和迭代反转法的思想恰好相反，递归反转法的实现思想是从链表的尾节点开始，依次向前遍历，遍历过程依次改变各节点的指向，即另其指向前一个节点。









​					

​			



​		






@@











